"""Generate professional multi-page PDF reports for matches.

Page 1: Dashboard — KPIs + key charts (age-up, TC idle by era)
Page 2: Economy — vill rate, farm gap, resource efficiency, production buildings
Page 3: Military — army composition, tech timings, military timing index
Page 4: Infrastructure — buildings, walling, key techs
"""

import json
import os
import tempfile
from datetime import datetime
from pathlib import Path

import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import numpy as np
from fpdf import FPDF

from .pdf_style import apply_agelytics_style, COLORS, get_player_colors
from .report import format_duration


class MatchPDF(FPDF):
    """Custom PDF with header/footer."""

    def __init__(self, match_data, player_name=None):
        super().__init__()
        self.match_data = match_data
        self.player_name = player_name
        self.temp_images = []

    def header(self):
        self.set_font("Helvetica", "B", 20)
        self.set_text_color(44, 62, 80)
        self.cell(0, 8, "AGELYTICS", 0, 0, "L")
        self.set_font("Helvetica", "", 10)
        self.set_text_color(127, 140, 141)
        self.cell(0, 8, f"Page {self.page_no()}", 0, 1, "R")
        self.ln(2)

    def footer(self):
        self.set_y(-12)
        self.set_font("Helvetica", "I", 7)
        self.set_text_color(127, 140, 141)
        self.cell(
            0, 10,
            f"Generated by Agelytics - github.com/tiuitobot/agelytics - {datetime.now().strftime('%Y-%m-%d %H:%M')}",
            0, 0, "C",
        )

    def separator(self):
        self.set_draw_color(189, 195, 199)
        self.set_line_width(0.3)
        self.line(10, self.get_y(), 200, self.get_y())
        self.ln(4)

    def section(self, title):
        self.ln(2)
        self.set_font("Helvetica", "B", 13)
        self.set_text_color(44, 62, 80)
        self.cell(0, 7, title, 0, 1, "L")
        self.ln(1)

    def subsection(self, title):
        self.set_font("Helvetica", "B", 10)
        self.set_text_color(44, 62, 80)
        self.cell(0, 6, title, 0, 1, "L")

    def text_line(self, text, bold=False, color=None):
        self.set_font("Helvetica", "B" if bold else "", 9)
        if color:
            self.set_text_color(*color)
        else:
            self.set_text_color(44, 62, 80)
        self.multi_cell(0, 4.5, text)
        self.ln(1)

    def kpi_row(self, kpis, y=None):
        """Draw a row of KPI cards. kpis = [(label, value, color_tuple_or_None), ...]"""
        if y is None:
            y = self.get_y()
        n = len(kpis)
        card_w = 190 / n
        for i, (label, value, color) in enumerate(kpis):
            x = 10 + i * card_w
            # Background
            if color:
                self.set_fill_color(*color)
                self.rect(x, y, card_w - 2, 18, "F")
                self.set_text_color(255, 255, 255)
            else:
                self.set_fill_color(245, 245, 245)
                self.rect(x, y, card_w - 2, 18, "F")
                self.set_text_color(44, 62, 80)
            # Value
            self.set_font("Helvetica", "B", 14)
            self.set_xy(x, y + 2)
            self.cell(card_w - 2, 7, str(value), 0, 0, "C")
            # Label
            self.set_font("Helvetica", "", 7)
            if color:
                self.set_text_color(240, 240, 240)
            else:
                self.set_text_color(127, 140, 141)
            self.set_xy(x, y + 10)
            self.cell(card_w - 2, 5, label, 0, 0, "C")
        self.set_y(y + 22)

    def add_chart(self, img_path, width=175):
        if img_path is None:
            return
        x = (210 - width) / 2
        # Check if enough space, otherwise new page
        if self.get_y() + 80 > 270:
            self.add_page()
        self.image(img_path, x=x, w=width)
        self.ln(3)
        self.temp_images.append(img_path)

    def cleanup(self):
        for img in self.temp_images:
            try:
                os.unlink(img)
            except Exception:
                pass


# ─── Chart generators ───────────────────────────────────────────


def _save_chart(fig):
    fd, path = tempfile.mkstemp(suffix=".png", prefix="agely_")
    os.close(fd)
    fig.savefig(path, dpi=150, bbox_inches="tight", facecolor="white")
    plt.close(fig)
    return path


def fmt(seconds):
    """MM:SS"""
    if seconds is None:
        return "--:--"
    m, s = divmod(int(seconds), 60)
    return f"{m:02d}:{s:02d}"


def chart_age_up(match):
    """Horizontal bar chart comparing age-up times."""
    apply_agelytics_style()
    age_ups = match.get("age_ups", [])
    if not age_ups:
        return None

    players_dict = {}
    for up in age_ups:
        players_dict.setdefault(up["player"], {})[up["age"]] = up["timestamp_secs"]

    ages = ["Feudal Age", "Castle Age", "Imperial Age"]
    labels = ["Feudal", "Castle", "Imperial"]
    player_names = list(players_dict.keys())
    colors = get_player_colors(len(player_names))

    fig, ax = plt.subplots(figsize=(7, 3))
    bar_h = 0.3
    for idx, pname in enumerate(player_names):
        vals = [players_dict[pname].get(a) for a in ages]
        y_pos = [i + idx * bar_h - bar_h * (len(player_names) - 1) / 2 for i in range(len(ages))]
        bars = ax.barh(
            [y for y, v in zip(y_pos, vals) if v],
            [v for v in vals if v],
            height=bar_h, label=pname, color=colors[idx],
        )
        for bar, v in zip(bars, [v for v in vals if v]):
            ax.text(bar.get_width() + 5, bar.get_y() + bar.get_height() / 2,
                    fmt(v), va="center", fontsize=8, color=COLORS["text_secondary"])

    ax.set_yticks(range(len(ages)))
    ax.set_yticklabels(labels)
    ax.set_xlabel("Time (seconds)")
    ax.set_title("Age-Up Timeline", fontsize=12, fontweight="bold")
    ax.legend(loc="lower right", fontsize=8)
    fig.tight_layout()
    return _save_chart(fig)


def chart_tc_idle_by_era(match):
    """Grouped bar chart: TC idle time per era, per player."""
    apply_agelytics_style()
    players = match.get("players", [])
    tc_idle_by_age = match.get("tc_idle_by_age", {})

    # Also try player-level fields
    if not tc_idle_by_age:
        for p in players:
            pname = p["name"]
            d = p.get("tc_idle_dark", 0) or 0
            f = p.get("tc_idle_feudal", 0) or 0
            c = p.get("tc_idle_castle", 0) or 0
            imp = p.get("tc_idle_imperial", 0) or 0
            if any([d, f, c, imp]):
                tc_idle_by_age[pname] = {"Dark": d, "Feudal": f, "Castle": c, "Imperial": imp}

    if not tc_idle_by_age:
        return None

    eras = ["Dark", "Feudal", "Castle", "Imperial"]
    player_names = [p["name"] for p in players]
    colors = get_player_colors(len(player_names))

    fig, ax = plt.subplots(figsize=(7, 3.5))
    x = np.arange(len(eras))
    width = 0.35

    for idx, pname in enumerate(player_names):
        vals = [tc_idle_by_age.get(pname, {}).get(era, 0) for era in eras]
        offset = (idx - (len(player_names) - 1) / 2) * width
        bars = ax.bar(x + offset, vals, width, label=pname, color=colors[idx])
        for bar in bars:
            h = bar.get_height()
            if h > 10:
                ax.text(bar.get_x() + bar.get_width() / 2, h + 2,
                        fmt(h), ha="center", va="bottom", fontsize=7)

    ax.set_xticks(x)
    ax.set_xticklabels(eras)
    ax.set_ylabel("Idle Time (seconds)")
    ax.set_title("TC Idle Time by Era", fontsize=12, fontweight="bold")
    ax.legend(fontsize=8)
    fig.tight_layout()
    return _save_chart(fig)


def chart_army_composition(match):
    """Horizontal bar chart of army units per player."""
    apply_agelytics_style()
    unit_prod = match.get("unit_production", {})
    if not unit_prod:
        return None

    eco_units = {"Villager", "Trade Cart", "Fishing Ship", "Transport Ship"}
    all_units = set()
    for units in unit_prod.values():
        for u, c in units.items():
            if u not in eco_units and c > 0:
                all_units.add(u)
    if not all_units:
        return None

    # Sort by total production
    unit_totals = {u: sum(unit_prod.get(p, {}).get(u, 0) for p in unit_prod) for u in all_units}
    sorted_units = sorted(all_units, key=lambda u: unit_totals[u])

    player_names = list(unit_prod.keys())
    colors = get_player_colors(len(player_names))

    fig, ax = plt.subplots(figsize=(7, max(3, len(sorted_units) * 0.4)))
    y = np.arange(len(sorted_units))
    bar_h = 0.35

    for idx, pname in enumerate(player_names):
        vals = [unit_prod.get(pname, {}).get(u, 0) for u in sorted_units]
        offset = (idx - (len(player_names) - 1) / 2) * bar_h
        ax.barh(y + offset, vals, bar_h, label=pname, color=colors[idx])

    ax.set_yticks(y)
    ax.set_yticklabels(sorted_units)
    ax.set_xlabel("Units Produced")
    ax.set_title("Army Composition", fontsize=12, fontweight="bold")
    ax.legend(loc="lower right", fontsize=8)
    fig.tight_layout()
    return _save_chart(fig)


def chart_walling(match):
    """Stacked bar: wall tiles by era per player."""
    apply_agelytics_style()
    wall_data = match.get("wall_tiles_by_age", {})
    if not wall_data or not any(any(v > 0 for v in ages.values()) for ages in wall_data.values()):
        return None

    eras = ["Dark", "Feudal", "Castle", "Imperial"]
    player_names = list(wall_data.keys())
    colors = get_player_colors(len(player_names))

    fig, ax = plt.subplots(figsize=(6, 3))
    x = np.arange(len(eras))
    width = 0.35

    for idx, pname in enumerate(player_names):
        vals = [wall_data[pname].get(era, 0) for era in eras]
        offset = (idx - (len(player_names) - 1) / 2) * width
        ax.bar(x + offset, vals, width, label=pname, color=colors[idx])

    ax.set_xticks(x)
    ax.set_xticklabels(eras)
    ax.set_ylabel("Wall Tiles")
    ax.set_title("Walling by Era", fontsize=12, fontweight="bold")
    ax.legend(fontsize=8)
    fig.tight_layout()
    return _save_chart(fig)


def chart_tech_timeline(match):
    """Gantt-style chart of key tech timings."""
    apply_agelytics_style()
    researches = match.get("researches", [])
    if not researches:
        return None

    # Key techs to show
    key_set = {
        "Loom", "Wheelbarrow", "Hand Cart",
        "Double-Bit Axe", "Bow Saw", "Two-Man Saw",
        "Horse Collar", "Heavy Plow", "Crop Rotation",
        "Gold Mining", "Gold Shaft Mining",
        "Fletching", "Bodkin Arrow", "Bracer",
        "Forging", "Iron Casting", "Blast Furnace",
        "Scale Mail Armor", "Chain Mail Armor", "Plate Mail Armor",
        "Scale Barding Armor", "Chain Barding Armor", "Plate Barding Armor",
        "Ballistics", "Chemistry", "Conscription",
        "Murder Holes", "Masonry", "Architecture",
    }

    players = match.get("players", [])
    player_names = [p["name"] for p in players]
    colors = get_player_colors(len(player_names))

    # Filter key techs
    filtered = [r for r in researches if r["tech"] in key_set]
    if not filtered:
        return None

    # Group by tech name (sorted by first timestamp)
    tech_order = {}
    for r in filtered:
        if r["tech"] not in tech_order:
            tech_order[r["tech"]] = r["timestamp_secs"]
    sorted_techs = sorted(tech_order.keys(), key=lambda t: tech_order[t], reverse=True)

    fig, ax = plt.subplots(figsize=(7, max(3, len(sorted_techs) * 0.3)))

    for r in filtered:
        tech_idx = sorted_techs.index(r["tech"])
        p_idx = player_names.index(r["player"]) if r["player"] in player_names else 0
        offset = (p_idx - (len(player_names) - 1) / 2) * 0.25
        ax.barh(tech_idx + offset, 15, left=r["timestamp_secs"], height=0.2,
                color=colors[p_idx], label=r["player"] if tech_idx == 0 else "")
        ax.text(r["timestamp_secs"] + 18, tech_idx + offset,
                fmt(r["timestamp_secs"]), fontsize=6, va="center")

    ax.set_yticks(range(len(sorted_techs)))
    ax.set_yticklabels(sorted_techs, fontsize=7)
    ax.set_xlabel("Game Time (seconds)")
    ax.set_title("Key Tech Timings", fontsize=12, fontweight="bold")

    # De-dup legend
    handles, labels = ax.get_legend_handles_labels()
    by_label = dict(zip(labels, handles))
    ax.legend(by_label.values(), by_label.keys(), fontsize=8, loc="lower right")
    fig.tight_layout()
    return _save_chart(fig)


# ─── PDF Generation ──────────────────────────────────────────────


def generate_match_pdf(match, output_path, player_name=None):
    """Generate a complete multi-page match PDF report."""
    pdf = MatchPDF(match, player_name)
    players = match.get("players", [])
    if not players:
        return None

    # Determine focus player
    focus = next((p for p in players if p["name"] == player_name), players[0])
    opponent = next((p for p in players if p["name"] != focus["name"]), None)

    # ═══════════════════════════════════════════════════════════
    # PAGE 1: DASHBOARD
    # ═══════════════════════════════════════════════════════════
    pdf.add_page()

    # Match headline
    pdf.set_font("Helvetica", "B", 16)
    pdf.set_text_color(44, 62, 80)
    result = "VICTORY" if focus.get("winner") else "DEFEAT"
    result_color = (39, 174, 96) if focus.get("winner") else (231, 76, 60)
    pdf.cell(0, 8, f"{focus['name']} ({focus.get('civ_name', '?')}) vs "
                    f"{opponent['name']} ({opponent.get('civ_name', '?')})" if opponent else focus["name"],
             0, 1, "L")

    pdf.set_font("Helvetica", "", 9)
    pdf.set_text_color(127, 140, 141)
    played_at = match.get("played_at", "Unknown")
    map_name = match.get("map_name", "Unknown")
    duration = fmt(match.get("duration_secs", 0))
    pdf.cell(0, 5, f"{played_at}  |  {map_name}  |  {duration}  |  {match.get('diplomacy', '1v1')}", 0, 1, "L")
    pdf.ln(3)

    # KPI Row 1: Result, Duration, ELO, Opening
    focus_elo = focus.get("elo", "?")
    opp_elo = opponent.get("elo", "?") if opponent else "?"
    opening = focus.get("opening_strategy") or match.get("openings", {}).get(focus["name"], "Unknown")
    pdf.kpi_row([
        ("Result", result, result_color),
        ("Duration", duration, None),
        ("ELO", f"{focus_elo} vs {opp_elo}", None),
        ("Opening", opening, (52, 73, 94)),
    ])

    # KPI Row 2: TC Idle, Housed, eAPM, Farm Gap
    tc_idle_total = focus.get("tc_idle_secs", 0)
    housed = match.get("housed_count", {}).get(focus["name"], 0)
    eapm = focus.get("eapm", "?")
    farm_gap = focus.get("farm_gap_average")
    farm_gap_str = f"{farm_gap:.1f}s" if farm_gap is not None else "N/A"
    pdf.kpi_row([
        ("TC Idle (total)", fmt(tc_idle_total), None),
        ("Housed", f"{housed}x", (231, 76, 60) if housed >= 5 else None),
        ("eAPM", str(eapm), None),
        ("Farm Gap", farm_gap_str, None),
    ])

    pdf.separator()

    # Age-Up chart
    pdf.section("Age-Up Timeline")
    age_chart = chart_age_up(match)
    pdf.add_chart(age_chart, width=170)

    # Age-up comparison text
    age_ups = match.get("age_ups", [])
    if age_ups and opponent:
        feudal_focus = next((a["timestamp_secs"] for a in age_ups
                             if a["player"] == focus["name"] and a["age"] == "Feudal Age"), None)
        feudal_opp = next((a["timestamp_secs"] for a in age_ups
                           if a["player"] == opponent["name"] and a["age"] == "Feudal Age"), None)
        if feudal_focus and feudal_opp:
            diff = feudal_focus - feudal_opp
            if abs(diff) > 5:
                faster = focus["name"] if diff < 0 else opponent["name"]
                pdf.text_line(f"{faster} reached Feudal {abs(diff):.0f}s faster ({fmt(min(feudal_focus, feudal_opp))}).")

    pdf.separator()

    # TC Idle by Era chart
    pdf.section("TC Idle by Era")
    tc_era_chart = chart_tc_idle_by_era(match)
    pdf.add_chart(tc_era_chart, width=170)

    # TC idle by era text summary
    for p in players:
        pname = p["name"]
        parts = []
        for era, field in [("Dark", "tc_idle_dark"), ("Feudal", "tc_idle_feudal"),
                           ("Castle", "tc_idle_castle"), ("Imperial", "tc_idle_imperial")]:
            val = p.get(field, 0) or 0
            if val > 10:
                parts.append(f"{era}: {fmt(val)}")
        if parts:
            pdf.text_line(f"  {pname}: {', '.join(parts)}")

    # ═══════════════════════════════════════════════════════════
    # PAGE 2: ECONOMY
    # ═══════════════════════════════════════════════════════════
    pdf.add_page()
    pdf.section("Economy")

    # Economy summary table
    for p in players:
        pname = p["name"]
        vills = match.get("unit_production", {}).get(pname, {}).get("Villager", 0)
        farms = match.get("buildings", {}).get(pname, {}).get("Farm", 0)
        fg = p.get("farm_gap_average")
        mil_idx = p.get("military_timing_index")
        tc_final = p.get("tc_count_final", "?")
        est_idle = p.get("estimated_idle_vill_time")
        res_eff = match.get("metrics", {}).get(pname, {}).get("resource_collection_efficiency")

        pdf.subsection(pname)
        lines = []
        lines.append(f"Villagers: {vills}  |  Farms: {farms}  |  Final TCs: {tc_final}")
        if fg is not None:
            quality = "excellent" if fg < 3 else "good" if fg < 6 else "needs work"
            lines.append(f"Farm Reseeding Gap: {fg:.1f}s avg ({quality})")
        if est_idle is not None:
            lines.append(f"Estimated Idle Villager Time: {fmt(est_idle)} (proxy)")
        if res_eff is not None:
            lines.append(f"Resource Efficiency: {res_eff:.0f} res/villager")
        if mil_idx is not None:
            style = "rush" if mil_idx < 0.7 else "boom" if mil_idx > 1.2 else "balanced"
            lines.append(f"Military Timing Index: {mil_idx:.2f} ({style})")
        for line in lines:
            pdf.text_line(f"  {line}")
        pdf.ln(2)

    pdf.separator()

    # Production Buildings by Age
    prod_buildings = match.get("production_buildings_by_age", {})
    if prod_buildings:
        pdf.section("Production Buildings by Age")
        abbrev = {"Archery Range": "Range", "Barracks": "Rax", "Stable": "Stable",
                  "Siege Workshop": "Siege", "Castle": "Castle", "Monastery": "Monastery",
                  "Dock": "Dock"}
        for pname in [p["name"] for p in players]:
            pb = prod_buildings.get(pname, {})
            if not pb:
                continue
            pdf.subsection(pname)
            for era in ["Dark", "Feudal", "Castle", "Imperial"]:
                buildings = pb.get(era, {})
                if buildings:
                    bstr = ", ".join(f"{count}x {abbrev.get(b, b)}" for b, count in buildings.items())
                    pdf.text_line(f"  {era}: {bstr}")
            pdf.ln(1)

    # ═══════════════════════════════════════════════════════════
    # PAGE 3: MILITARY
    # ═══════════════════════════════════════════════════════════
    pdf.add_page()
    pdf.section("Army Composition")
    army_chart = chart_army_composition(match)
    pdf.add_chart(army_chart, width=170)

    # Opening strategies
    openings = match.get("openings", {})
    if openings:
        pdf.subsection("Opening Strategies")
        for pname in [p["name"] for p in players]:
            op = openings.get(pname, focus.get("opening_strategy") if pname == focus["name"] else "Unknown")
            pdf.text_line(f"  {pname}: {op}")
        pdf.ln(2)

    pdf.separator()

    # Tech Timings
    pdf.section("Key Tech Timings")
    tech_chart = chart_tech_timeline(match)
    pdf.add_chart(tech_chart, width=170)

    # Tech assessment text
    try:
        from .tech_timings import extract_key_techs, format_timing, assess_timing
        for p in players:
            pname = p["name"]
            key_techs = extract_key_techs(match, pname)
            if not key_techs:
                continue
            pdf.subsection(pname)
            by_cat = {}
            for td in key_techs:
                by_cat.setdefault(td["category"], []).append(td)
            for cat in ["Economy", "Military", "Blacksmith", "University"]:
                techs = by_cat.get(cat, [])
                if techs:
                    parts = []
                    for td in techs[:5]:
                        a = assess_timing(td["tech"], td["timestamp_secs"])
                        indicator = " [OK]" if a == "Good" else " [LATE]" if a == "Poor" else ""
                        parts.append(f"{td['tech']} {fmt(td['timestamp_secs'])}{indicator}")
                    pdf.text_line(f"  {cat}: {', '.join(parts)}")
            pdf.ln(1)
    except ImportError:
        pass

    # ═══════════════════════════════════════════════════════════
    # PAGE 4: INFRASTRUCTURE
    # ═══════════════════════════════════════════════════════════
    pdf.add_page()
    pdf.section("Buildings")

    buildings = match.get("buildings", {})
    if buildings:
        for p in players:
            pname = p["name"]
            pb = buildings.get(pname, {})
            if not pb:
                continue
            pdf.subsection(pname)
            # Group: eco, military, defense, other
            eco_b = ["Town Center", "Farm", "Mill", "Lumber Camp", "Mining Camp", "Market", "House"]
            mil_b = ["Barracks", "Archery Range", "Stable", "Siege Workshop", "Castle"]
            def_b = ["Watch Tower", "Guard Tower", "Keep", "Bombard Tower", "Gate", "Palisade Wall", "Stone Wall", "Fortified Wall"]

            for group_name, group_list in [("Economy", eco_b), ("Military", mil_b), ("Defense", def_b)]:
                items = [(b, pb[b]) for b in group_list if b in pb and pb[b] > 0]
                if items:
                    istr = ", ".join(f"{count}x {b}" for b, count in items)
                    pdf.text_line(f"  {group_name}: {istr}")

            # Others
            shown = set(eco_b + mil_b + def_b)
            others = [(b, c) for b, c in pb.items() if b not in shown and c > 0]
            if others:
                ostr = ", ".join(f"{c}x {b}" for b, c in others)
                pdf.text_line(f"  Other: {ostr}")
            pdf.ln(1)

    pdf.separator()

    # Walling
    pdf.section("Walling")
    wall_chart = chart_walling(match)
    if wall_chart:
        pdf.add_chart(wall_chart, width=150)
    else:
        pdf.text_line("  No walling data available.")

    wall_data = match.get("wall_tiles_by_age", {})
    if wall_data:
        for pname in [p["name"] for p in players]:
            pw = wall_data.get(pname, {})
            if pw and any(v > 0 for v in pw.values()):
                total = sum(pw.values())
                parts = [f"{era}: {pw.get(era, 0)}" for era in ["Dark", "Feudal", "Castle", "Imperial"] if pw.get(era, 0) > 0]
                pdf.text_line(f"  {pname}: {', '.join(parts)} (Total: {total} tiles)")

    pdf.separator()

    # Housed events detail
    housed_data = match.get("housed_count", {})
    if housed_data and any(v > 0 for v in housed_data.values()):
        pdf.section("Housed Events")
        for pname in [p["name"] for p in players]:
            count = housed_data.get(pname, 0)
            if count > 0:
                severity = "Critical" if count >= 7 else "Warning" if count >= 4 else "Minor"
                pdf.text_line(f"  {pname}: {count} times ({severity})")

    # ─── End ─────────────────────────────────────────────────
    pdf.output(output_path)
    pdf.cleanup()
    return output_path


if __name__ == "__main__":
    from .db import get_db, get_last_match

    conn = get_db()
    match = get_last_match(conn)
    conn.close()

    if match:
        output = "reports/match_report.pdf"
        os.makedirs("reports", exist_ok=True)
        generate_match_pdf(match, output, player_name="blzulian")
        print(f"Generated: {output}")
    else:
        print("No match found")
